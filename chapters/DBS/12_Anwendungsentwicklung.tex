\section{Anwendungsentwicklung}
\label{sec:anwendungeentwicklung}

\textbf{Client-Server-Architektur}
\begin{figure}[H]\centering\label{ClientServer}\includegraphics[width=0.25\textwidth]{ClientServer}\end{figure}
\begin{items}
	\item Erfordert
	\begin{enumeration}
		\item Kenntnis über angebotene Dienste
		\item Protokoll zur Regelung der Interaktion
	\end{enumeration}
\end{items}

\textbf{Zwei Schichten-Architektur}
\begin{figure}[H]\centering\label{ZweiSchichtenArchitektur}\includegraphics[width=0.33\textwidth]{ZweiSchichtenArchitektur}\end{figure}

\textbf{Drei Schichten-Architektur}
\begin{figure}[H]\centering\label{DreiSchichtenArchitektur}\includegraphics[width=0.33\textwidth]{DreiSchichtenArchitektur}\end{figure}

\textbf{Anwendungslogik}
\begin{items}
	\item \underline{Anwendungslogik}: Algorithmen, die anwendungsspezifisches Wissen beinhalten
	\item Personal-DB entählt Mitarbeiter-Daten
		\\*
		\( \leadsto \) Anwendung: schlägt Teamleiter für konkrete Projekte vor
		\\*
		\( \leadsto \) Bedeutsamkeit der Fähigkeiten usw. Anwendungsteil
\end{items}

\textbf{Cursor-Konzept}
\begin{items}
	\item Cursor \( \equiv \) Iterator
	\item Programmiersprachen: einzelne Datenobjekte als zugrundeliegende Struktur
\end{items}

\newpage

\textbf{Programmiersprachenanbindung}
\begin{figure}[H]\centering\label{Programmiersprachenanbindung}\includegraphics[width=0.33\textwidth]{Programmiersprachenanbindung}\end{figure}

\textbf{Prepared Statements}
\begin{items}
	\item Reduzieren Ausführungszeit, da bereits vorab kompiliert
	\item
		\begin{lstlisting}[language=java,showstringspaces=false]
PreparedStatement updateSales = 
  con.prepareStatement('UPDATE COFFEES 
  SET SALES = ? WHERE COF_NAME LIKE ?');
		\end{lstlisting}
	\item \lstinline[language=java]{upcdateSales.setInt(1,75);}
\end{items}

\textbf{Gespeicherte Prozeduren}
\begin{items}
	\item In DB-Server verwaltete und ausgeführte Software-Module in Form von Prozeduren/Funktionen
	\item Aufruf aus Anwendungen/Anfragen heraus
	\item \( \leadsto \) Weniger Kontextwechsel in Anwendung
\end{items}

\textbf{Variablen und Typen}
\begin{items}
	\item \lstinline[language=sql]{DECLARE preis NUMBER;}
	\item Stellt sicher, dass Attributtyp in DB identisch zu Typ in Programm ist
\end{items}

\textbf{Kontrollfluss}
\begin{items}
	\item
	\begin{lstlisting}[language=sql]
DECLARE
  a NUMBER;
  b NUMBER;
BEGIN
  SELECT e,f INTO a,b
  FROM T1 WHERE e>1;
  IF b=1 THEN
    INSERT INTO T1 VALUES(b,a);
  ELSE
    INSERT INTO T1 VALUES(b+10,a+10);
  END IF;
END;
.
run;
	\end{lstlisting}
\end{items}

\textbf{Performance Anti-Patterns}
\begin{items}
	\item \underline{Excessive Dynamic Allocation}:
		\\*
		Häufige unnötige Objekterstellung/-zerstörung derselben Klasse
	\item \underline{The Stifle}:
		\\*
		Unpassende DB-Schnittstellennutzung
	\item \underline{Circuitous Treasure Hunt}:
		\\*
		Abfrage von Relation A, damit Relation B abfragen,\dots
	\item \underline{Sisyphus DB Retrieval}:
		\\*
		Riesige Datenmenge abfragen, obwohl nur wenige Einträge nötig
	\item \underline{Spaghetti Query}:
		\\*
		Mehrere Informationsbedürfnisse in einer Anfrage
	\item \underline{Insufficient Caching}:
		\\*
		Zu wenig Caching
	\item \underline{Wrong Caching Strategy}:
		\\*
		Falsche Objekte werden in Cache abgelegt
\end{items}

\begin{fragen}
	\begin{enumeration}
		\item Erläutern Sie die Dimensionen des Raums der Möglichkeiten des Zugriffs auf Datenbanken aus Anwendungen heraus.
		\item Erläutern Sie die Begriffe
		\begin{enumeration}
			\item Anwendungslogik,
			\item Cursor,
			\item Call-Level Interface,
			\item Host-Variablen.
		\end{enumeration}
		\item Kann man mit Embedded SQL sicherstellen, dass keine Schema-spezifischen Fehler auftreten? Wenn ja, wie geht es?
		\item Was sind die Vorteile von Stored Procedures? Erläutern Sie das Konzept.
	\end{enumeration}
\end{fragen}